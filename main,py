from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, InputMediaPhoto, KeyboardButton, ReplyKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, filters, ConversationHandler, CallbackContext, CallbackQueryHandler
import os
import json
import requests
from amocrm.v2 import Lead as _Lead, tokens, Pipeline, custom_field

from config import Config

CATEGORY, SUBCATEGORY, OTHER_SUBCATEGORY, CONFIRM_SUBCATEGORY, SIZE_KNOWN, LENGTH, WIDTH, GLASS, COLOR, OTHER_COLOR, CONFIRM_COLOR, VISUAL, SOURCE, OTHER_SOURCE, CONFIRM_SOURCE, PHONE_NUMBER, COMPLETE, CONFIRM_ORDER = range(18)

CATEGORIES = {
    "Перегородка": ["Стационарная", "Распашная", "Откатная", "Каскадная", "Гармошка", "Безрамочная"],
    "Чаша": [],
    "Стеллаж": [],
    "Зеркало": []
}

GLASS_OPTIONS = ["Матовое", "Прозрачное", "Рифленое", "Тонированное"]
COLOR_OPTIONS = ["Черный", "Белый", "Золотой"]
SOURCE_OPTIONS = ["Фарпост", "Инстаграм", "Дизайнер", "По рекомендации"]

PHOTOS = [
    {"path": f"{i}.jpg", "caption": f"Категория: {cat}"}
    for i, cat in zip(range(1, 19), [
        *["Каскадная"] * 4,
        *["Гармошка"] * 3,
        *["Распашная"] * 2,
        *["Откатная"] * 4,
        *["Безрамочная"] * 2,
        *["Стационарная"] * 3
    ])
]

# токены AmoCRM

def load_tokens():
    if os.path.exists(Config.TOKEN_FILE):
        with open(Config.TOKEN_FILE, "r") as file:
            return json.load(file)
    return None

def save_tokens(tokens_data):
    with open(Config.TOKEN_FILE, "w") as file:
        json.dump(tokens_data, file)

def refresh_tokens():
    tokens_data = load_tokens()
    if not tokens_data:
        print("❌ Ошибка при загрузке токенов")
        return None

    response = requests.post(
        f"https://{Config.SUBDOMAIN}.amocrm.ru/oauth2/access_token",
        json={
            "client_id": Config.CLIENT_ID,
            "client_secret": Config.CLIENT_SECRET,
            "grant_type": "refresh_token",
            "refresh_token": tokens_data["refresh_token"],
            "redirect_uri": Config.REDIRECT_URI
        }
    )

    if response.status_code == 200:
        new_tokens = response.json()
        save_tokens(new_tokens)
        return new_tokens["access_token"]
    else:
        print("❌ Ошибка при обновлении токенов")
        return None

def get_access_token():
    tokens_data = load_tokens()
    if not tokens_data:
        print("❌ Токены не найдены")
        return None
    return tokens_data.get("access_token") or refresh_tokens()

async def main_menu(update: Update, context: CallbackContext):
    
    context.user_data.clear()

    if update.message and update.message.text == "/start":
        welcome_text = (
            "👋 Здравствуйте! Спасибо, что выбрали нашу компанию. На связи бот компании Svarka&Design. 🌟\n\n"
            "Я готов помочь вам с выбором вашего заказа, показать примеры работ и рассчитать стоимость.\n\n"
            "✨ Чтобы вызвать меню в любой момент, вы можете:\n"
            "- Использовать команду /menu\n"
            "- Написать в чат слово \"меню\"\n\n"
            "Мы всегда рядом, чтобы сделать ваш опыт приятным и удобным! 😊"
        ) 
        await update.message.reply_text(welcome_text)

    keyboard = [
        [InlineKeyboardButton("📝 ЗАКАЗАТЬ РАСЧЁТ", callback_data='order')],
        [InlineKeyboardButton("🖼️ Портфолио", callback_data='gallery')],
        [InlineKeyboardButton("🏢 О компании", callback_data='about')],
        [InlineKeyboardButton("📞 Обратная связь", callback_data='feedback')],
        [InlineKeyboardButton("🛠 Техподдержка", callback_data='support')], 
        [InlineKeyboardButton("❓ FAQ", callback_data='faq')],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    if update.callback_query:
        await update.callback_query.edit_message_text("Выберите раздел:", reply_markup=reply_markup)
    else:
        await update.message.reply_text("Выберите раздел:", reply_markup=reply_markup)

    return ConversationHandler.END

# О компании
async def about_company(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    about_text = (
        "🌟 *Создаем уникальные металлоконструкции, которые вдохновляют!*\n\n"
        "Мы специализируемся на производстве:\n"
        "🔹 *Стильных перегородок* — для зонирования пространства с эстетикой и функциональностью.\n"
        "🔹 *Костровых чаш* — создаем атмосферу уюта и тепла для вашего дома или ресторана.\n"
        "🔹 *Эксклюзивных зеркал* — добавляем изысканности любому интерьеру.\n"
        "🔹 *Леерных ограждений и лестниц* — сочетание безопасности, надежности и современного дизайна.\n\n"
        "✨ *Почему выбирают нас?*\n"
        "✅ *Порошково-полимерная покраска* — долговечность и безупречный внешний вид.\n"
        "✅ *Индивидуальный подход* — каждый проект создается с учетом ваших пожеланий.\n"
        "✅ *Опыт и репутация* — 7 лет на рынке Дальнего Востока, сотни довольных клиентов.\n\n"
        "🏆 *Наши работы говорят за нас:*\n"
        "Мы гордимся тем, что наши изделия украшают такие объекты, как:\n"
        "• Vladivostok International Airport\n"
        "• UMAMI\n"
        "• Посольство Красоты\n"
        "• Геометрия фитнеса\n"
        "• ZUMA\n"
        "• CEDRA\n"
        "• Vladivostok Design Week\n"
        "• VVO Apartments Group\n\n"
        "💎 *Svarka&Design* — это не просто металлоконструкции, это искусство, воплощенное в металле.\n"
        "Доверьте нам ваш проект, и мы создадим то, что станет вашей гордостью!\n"
    )

    keyboard = [
        [InlineKeyboardButton("🔙 Назад", callback_data='back_to_main')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text(
        about_text,
        reply_markup=reply_markup,
        parse_mode="Markdown"
    )

current_photo_index = 0

async def gallery(update: Update, context: CallbackContext):
    global current_photo_index
    current_photo_index = 0
    await show_photo(update, context)

async def show_photo(update: Update, context: CallbackContext):
    global current_photo_index
    photo = PHOTOS[current_photo_index]

    keyboard = [
        [
            InlineKeyboardButton("⬅️ Назад", callback_data='prev_photo'),
            InlineKeyboardButton("➡️ Вперед", callback_data='next_photo')
        ],
        [InlineKeyboardButton("🔙 Назад в меню", callback_data='back_to_main')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    if 'photo_message_id' in context.user_data:
        try:
            await context.bot.edit_message_media(
                chat_id=update.callback_query.message.chat_id,
                message_id=context.user_data['photo_message_id'],
                media=InputMediaPhoto(media=open(photo['path'], 'rb'), caption=photo['caption']),
                reply_markup=reply_markup
            )
        except Exception as e:
            print("❌ Произошла какая-то ошибка, напишите нам [в Telegram](https://t.me/+79953969908) об этом!!")
    else:

        message = await update.callback_query.message.reply_photo(
            photo=open(photo['path'], 'rb'),
            caption=photo['caption'],
            reply_markup=reply_markup
        )
        context.user_data['photo_message_id'] = message.message_id

# Обработчик для навигации по фотографиям
async def handle_photo_navigation(update: Update, context: CallbackContext):
    global current_photo_index
    query = update.callback_query
    await query.answer()

    if query.data == 'next_photo':
        current_photo_index += 1
        if current_photo_index >= len(PHOTOS):
            current_photo_index = 0
    elif query.data == 'prev_photo':
        current_photo_index -= 1
        if current_photo_index < 0:
            current_photo_index = len(PHOTOS) - 1
    elif query.data == 'back_to_main':
        if 'photo_message_id' in context.user_data:
            try:
                await context.bot.delete_message(
                    chat_id=query.message.chat_id,
                    message_id=context.user_data['photo_message_id']
                )
                del context.user_data['photo_message_id']
            except Exception as e:
                print("❌ Произошла какая-то ошибка, напишите нам [в Telegram](https://t.me/+79953969908) об этом!!")

        current_photo_index = 0

        await query.message.reply_text("Выберите раздел:", reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("📝 ЗАКАЗАТЬ РАСЧЁТ", callback_data='order')],
            [InlineKeyboardButton("🖼️ Портфолио", callback_data='gallery')],
            [InlineKeyboardButton("🏢 О компании", callback_data='about')],
            [InlineKeyboardButton("📞 Обратная связь", callback_data='feedback')],
            [InlineKeyboardButton("🛠 Техподдержка", callback_data='support')],
            [InlineKeyboardButton("❓ FAQ", callback_data='faq')],
        ]))
        return

    await show_photo(update, context)

# Обратная связь
async def feedback(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    feedback_text = (
        "📞 *Свяжитесь с нами!*\n\n"
        "🔗 *WhatsApp:* [+7 914 728 18 18](https://wa.me/79147281818)\n"
        "📸 *Instagram:* [@svarkavl](https://www.instagram.com/svarkavl)\n"
        "🌐 *Сайт:* [svarka25.ru](https://svarka25.ru/)\n"
        "📍 *Мы в 2ГИС:* [Открыть в 2ГИС](https://2gis.ru/vladivostok/geo/70000001076981081)\n\n"
        "Мы всегда готовы ответить на ваши вопросы и помочь с выбором! 😊"
    )

    keyboard = [
        [InlineKeyboardButton("🔙 Назад", callback_data='back_to_main')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text(
        feedback_text,
        reply_markup=reply_markup,
        parse_mode="Markdown",
        disable_web_page_preview=False
    )

# FAQ
async def faq(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    faq_text = (
        "❓ *Часто задаваемые вопросы:*\n\n"
        "1. *Как заказать?*\n"
        "— Перейдите в раздел «Заказ КП», укажите все данные, и в течение дня мы вышлем первичное КП. Далее с вами свяжется менеджер.\n\n"
        "2. *Какие сроки выполнения?*\n"
        "— 35 рабочих дней с момента замера объекта.\n\n"
        "3. *Как оплатить заказ?*\n"
        "— После согласования КП и замеров на объекте менеджер составляет договор на оплату. Предоплата составляет 70%. Доплата — 30% после выполнения работы.\n\n"
        "Если у вас остались вопросы, свяжитесь с нами через раздел «Обратная связь»!"
    )

    keyboard = [
        [InlineKeyboardButton("🔙 Назад", callback_data='back_to_main')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text(
        faq_text,
        reply_markup=reply_markup,
        parse_mode="Markdown"
    )

async def support(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    support_text = (
        "🛠 Техническая поддержка:\n\n"
        "Если у вас возникли проблемы с ботом или заказом, свяжитесь с нами:\n\n"
        "📞 Контакт: `+7 (914) 728-18-18`\n"
        "📲 Telegram: [Рабочий аккаунт](https://t.me/+79953969908)\n"
        "🔗 WhatsApp: [+7 914 728 18 18](https://wa.me/79147281818)\n"
        "📸 Instagram: [@svarkavl](https://www.instagram.com/svarkavl)\n"
        "📍 *2ГИС:* [Открыть в 2ГИС](https://2gis.ru/vladivostok/geo/70000001076981081)\n\n"
        "Мы всегда готовы помочь и решить любые вопросы! 😊"
    )

    keyboard = [[InlineKeyboardButton("🔙 Назад", callback_data='back_to_main')]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text(
        support_text,
        reply_markup=reply_markup,
        parse_mode="Markdown",
        disable_web_page_preview=False
    )


async def main_menu_from_query(query):
    keyboard = [
        [InlineKeyboardButton("📝 ЗАКАЗАТЬ РАСЧЁТ", callback_data='order')],
        [InlineKeyboardButton("🖼️ Портфолио", callback_data='gallery')],
        [InlineKeyboardButton("🏢 О компании", callback_data='about')],
        [InlineKeyboardButton("📞 Обратная связь", callback_data='feedback')],
        [InlineKeyboardButton("🛠 Техподдержка", callback_data='support')],
        [InlineKeyboardButton("❓ FAQ", callback_data='faq')],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text("Выберите раздел:", reply_markup=reply_markup)

# Начало процесса заказа КП
async def start_order(update: Update, context: CallbackContext) -> int:
    context.user_data.clear()
    keyboard = [[InlineKeyboardButton(cat, callback_data=cat)] for cat in CATEGORIES.keys()]
    keyboard.append([InlineKeyboardButton("🔙 Назад", callback_data="back_to_main")])
    reply_markup = InlineKeyboardMarkup(keyboard)

    if update.callback_query:
        await update.callback_query.edit_message_text("Выберите категорию:", reply_markup=reply_markup)
    else:
        await update.message.reply_text("Выберите категорию:", reply_markup=reply_markup)
    
    return CATEGORY

# Выбор подкатегории
async def choose_subcategory(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    category = query.data

    if category == "back_to_main":
        await main_menu_from_query(query)
        return ConversationHandler.END

    if category not in CATEGORIES:
        return await start_order(update, context)

    context.user_data["category"] = category
    await query.answer()

    if CATEGORIES[category]:
        keyboard = [[InlineKeyboardButton(sub, callback_data=f"sub_{sub}")] for sub in CATEGORIES[category]]
        keyboard.append([InlineKeyboardButton("Другое", callback_data="other_subcategory")])
        keyboard.append([InlineKeyboardButton("🔙 Назад", callback_data="back_to_category")])
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text("Выберите подкатегорию:", reply_markup=reply_markup)
        return SUBCATEGORY
    else:
        return await ask_size(update, context)
    
async def handle_subcategory_selection(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    subcategory = query.data.replace("sub_", "")

    context.user_data["subcategory"] = subcategory
    await query.answer()
    
    return await ask_size(update, context)

async def back_to_category(update: Update, context: CallbackContext) -> int:
    await start_order(update, context)
    return CATEGORY

async def ask_size(update: Update, context: CallbackContext) -> int:
    if update.callback_query:
        query = update.callback_query
        if query.data == "back_to_category":
            return await back_to_category(update, context)
        await query.answer()

        keyboard = [
            [InlineKeyboardButton("Да", callback_data="yes"), InlineKeyboardButton("Нет", callback_data="no")],
            [InlineKeyboardButton("🔙 Назад", callback_data="back_to_category")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text("Знаете ли вы размер?", reply_markup=reply_markup)
    elif update.message:
        keyboard = [
            [InlineKeyboardButton("Да", callback_data="yes"), InlineKeyboardButton("Нет", callback_data="no")],
            [InlineKeyboardButton("🔙 Назад", callback_data="back_to_category")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await update.message.reply_text("Знаете ли вы размер?", reply_markup=reply_markup)

    return SIZE_KNOWN

# Возврат в главное меню
async def back_to_main(update: Update, context: CallbackContext):
    query = update.callback_query
    await query.answer()

    if 'photo_message_id' in context.user_data:
        try:
            await context.bot.delete_message(
                chat_id=query.message.chat_id,
                message_id=context.user_data['photo_message_id']
            )
            del context.user_data['photo_message_id']
        except Exception as e:
            print("❌ Произошла какая-то ошибка, напишите нам [в Telegram](https://t.me/+79953969908) об этом!!")
    await main_menu_from_query(query)
    return ConversationHandler.END

# Обработка ответа на вопрос о размере
async def handle_size_known(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    await query.answer()

    if query.data == "yes":
        return await ask_length(update, context)
    elif query.data == "no":
        context.user_data["length"] = "0"
        context.user_data["width"] = "0"
        return await ask_glass(update, context)
    elif query.data == "back_to_category":
        return await back_to_category(update, context)

# Если знает размер, запрашиваем длину
async def ask_length(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    await query.answer()

    context.user_data["length_input"] = ""

    keyboard = generate_number_keyboard("length")
    keyboard.append([InlineKeyboardButton("🔙 Назад", callback_data="back_to_size_known")])
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text("Введите высоту (в метрах) с помощью кнопок:", reply_markup=reply_markup)
    return LENGTH

async def back_to_size_known(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    await query.answer()
    return await ask_size(update, context)

async def handle_length_input(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    await query.answer()

    data = query.data.split("_")
    action = data[1]

    if action.isdigit():
        context.user_data["length_input"] += action
    elif action == "dot":
        if "." not in context.user_data["length_input"]:
            context.user_data["length_input"] += "."
    elif action == "clear":
        context.user_data["length_input"] = ""
    elif action == "done":
        if not context.user_data["length_input"] or context.user_data["length_input"] == ".":
            await query.answer("Введите корректное число!", show_alert=True)
            return LENGTH
        context.user_data["length"] = context.user_data["length_input"]
        return await ask_width(update, context)

    keyboard = generate_number_keyboard("length", allow_dot="." not in context.user_data["length_input"])
    keyboard.append([InlineKeyboardButton("🔙 Назад", callback_data="back_to_size_known")])
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text(f"Введите высоту (в метрах): {context.user_data['length_input']}", reply_markup=reply_markup)
    return LENGTH

def generate_number_keyboard(prefix: str, allow_dot: bool = True):
    keyboard = [
        [InlineKeyboardButton("1", callback_data=f"{prefix}_1"),
         InlineKeyboardButton("2", callback_data=f"{prefix}_2"),
         InlineKeyboardButton("3", callback_data=f"{prefix}_3")],
        [InlineKeyboardButton("4", callback_data=f"{prefix}_4"),
         InlineKeyboardButton("5", callback_data=f"{prefix}_5"),
         InlineKeyboardButton("6", callback_data=f"{prefix}_6")],
        [InlineKeyboardButton("7", callback_data=f"{prefix}_7"),
         InlineKeyboardButton("8", callback_data=f"{prefix}_8"),
         InlineKeyboardButton("9", callback_data=f"{prefix}_9")],
        [InlineKeyboardButton("0", callback_data=f"{prefix}_0"),
         InlineKeyboardButton("⬅️ Очистить", callback_data=f"{prefix}_clear")]
    ]

    if allow_dot:
        keyboard[3].insert(1, InlineKeyboardButton(".", callback_data=f"{prefix}_dot"))

    keyboard.append([InlineKeyboardButton("✅ Готово", callback_data=f"{prefix}_done")])

    return keyboard

async def ask_width(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    await query.answer()

    context.user_data["width_input"] = ""

    keyboard = generate_number_keyboard("width")
    keyboard.append([InlineKeyboardButton("🔙 Назад", callback_data="back_to_length")])
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text("Введите ширину (в метрах) с помощью кнопок:", reply_markup=reply_markup)
    return WIDTH

async def back_to_length(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    await query.answer()
    return await ask_length(update, context)

async def handle_width_input(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    await query.answer()

    data = query.data.split("_")
    action = data[1]

    if action.isdigit():
        context.user_data["width_input"] += action
    elif action == "dot":
        if "." not in context.user_data["width_input"]:
            context.user_data["width_input"] += "."
    elif action == "clear":
        context.user_data["width_input"] = ""
    elif action == "done":
        if not context.user_data["width_input"] or context.user_data["width_input"] == ".":
            await query.answer("Введите корректное число!", show_alert=True)
            return WIDTH
        context.user_data["width"] = context.user_data["width_input"]
        return await ask_glass(update, context)

    keyboard = generate_number_keyboard("width", allow_dot="." not in context.user_data["width_input"])
    keyboard.append([InlineKeyboardButton("🔙 Назад", callback_data="back_to_length")])
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text(f"Введите ширину (в метрах): {context.user_data['width_input']}", reply_markup=reply_markup)
    return WIDTH

async def ask_glass(update: Update, context: CallbackContext) -> int:
    if context.user_data.get("category") != "Перегородка":
        context.user_data["glass"] = "Не указано"
        return await ask_color(update, context)

    query = update.callback_query
    await query.answer()

    keyboard = [[InlineKeyboardButton(opt, callback_data=opt)] for opt in GLASS_OPTIONS]
    keyboard.append([InlineKeyboardButton("🔙 Назад", callback_data="back_to_size_known")])
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text("Какое стекло хотите?", reply_markup=reply_markup)
    return GLASS

async def ask_color(update: Update, context: CallbackContext) -> int:
    if update.callback_query:
        query = update.callback_query
        context.user_data["glass"] = query.data
        await query.answer()
        send = query.edit_message_text
    else:
        send = update.message.reply_text

    keyboard = [[InlineKeyboardButton(opt, callback_data=opt)] for opt in COLOR_OPTIONS]
    keyboard.append([InlineKeyboardButton("Другое", callback_data="other_color")])
    keyboard.append([InlineKeyboardButton("🔙 Назад", callback_data="back_to_glass")])
    reply_markup = InlineKeyboardMarkup(keyboard)

    await send("Выберите цвет:", reply_markup=reply_markup)
    return COLOR


async def handle_color_selection(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    selected_option = query.data

    if selected_option in COLOR_OPTIONS:
        context.user_data["color"] = selected_option
    else:
        await query.answer("Ошибка: выберите цвет из списка!", show_alert=True)
        return COLOR

    await query.answer()
    return await ask_phone_number(update, context)
    
async def back_to_glass(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    await query.answer()
    return await ask_glass(update, context)

async def ask_phone_number(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    await query.answer()

    keyboard = [
        [KeyboardButton("📞 Поделиться контактом", request_contact=True)],
        [KeyboardButton("🔙 Назад")]
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)

    await query.message.reply_text(
        "Поделитесь с нами вашим номером телефона, чтобы мы смогли продолжить работу с вами:",
        reply_markup=reply_markup
    )
    return PHONE_NUMBER

async def handle_phone_number(update: Update, context: CallbackContext) -> int:
    if update.message.text and update.message.text.strip() == "🔙 Назад":
        await update.message.reply_text("Хорошо, вернёмся к выбору цвета!", reply_markup=ReplyKeyboardRemove())
        return await ask_color(update, context)

    if update.message.contact:
        phone_number = update.message.contact.phone_number

    elif update.message.text:
        phone_number = update.message.text.strip()
    else:
        await update.message.reply_text("Пожалуйста, отправьте номер телефона.")
        return PHONE_NUMBER

    context.user_data["phone_number"] = phone_number

    await update.message.reply_text(
        "Спасибо! Ваш номер сохранен.",
        reply_markup=ReplyKeyboardRemove()
    )

    return await ask_source(update, context)



    
async def back_to_phone_number(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    await query.answer()
    return await ask_phone_number(update, context)

async def ask_source(update: Update, context: CallbackContext) -> int:
    keyboard = [[InlineKeyboardButton(opt, callback_data=opt)] for opt in SOURCE_OPTIONS]
    keyboard.append([InlineKeyboardButton("Другое", callback_data="other_source")])
    keyboard.append([InlineKeyboardButton("🔙 Назад", callback_data="back_to_phone_number")])
    reply_markup = InlineKeyboardMarkup(keyboard)

    if update.callback_query:
        query = update.callback_query
        await query.answer()
        await query.edit_message_text("Откуда узнали о нас?", reply_markup=reply_markup)
    elif update.message:
        await update.message.reply_text("Откуда узнали о нас?", reply_markup=reply_markup)

    return SOURCE


async def handle_source_selection(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    selected_source = query.data 

    if selected_source in SOURCE_OPTIONS:
        context.user_data["source"] = selected_source
    else:
        await query.answer("Ошибка: выберите источник из списка!", show_alert=True)
        return SOURCE

    await query.answer()
    return await confirm_order(update, context)

async def back_to_color(update: Update, context: CallbackContext) -> int:
    if update.callback_query:
        await update.callback_query.answer()
        return await ask_color(update, context)
    elif update.message:
        return await ask_color(update, context)

async def handle_other_option(update: Update, context: CallbackContext, field: str, next_state: int, back_state: int) -> int:
    query = update.callback_query
    if query:
        await query.answer()
        await query.edit_message_text(f"Напишите свой вариант:")
        return next_state

async def save_other_option(update: Update, context: CallbackContext, field: str, confirm_state: int) -> int:
    user_input = update.message.text.strip()
    if not user_input:
        await update.message.reply_text("Пожалуйста, введите корректное значение.")
        return confirm_state

    context.user_data[field] = user_input
    keyboard = [
        [InlineKeyboardButton("Сохранить", callback_data=f"confirm_{field}"),
        InlineKeyboardButton("Переписать", callback_data=f"rewrite_{field}")]
    ]

    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text(
        f"Вы ввели: {user_input}.\nПодтвердите или измените:",
        reply_markup=reply_markup
    )
    return confirm_state

async def confirm_other_option(update: Update, context: CallbackContext, field: str, next_state: int, back_state: int) -> int:
    query = update.callback_query
    await query.answer()

    if query.data == f"rewrite_{field}":
        await query.edit_message_text(f"Напишите нам свой вариант!:")
        return back_state
    elif query.data == f"confirm_{field}":
        await query.edit_message_text("Значение сохранено. Переходим к следующему шагу.")
        return next_state

async def handle_other_subcategory(update: Update, context: CallbackContext) -> int:
    return await handle_other_option(update, context, "subcategory", OTHER_SUBCATEGORY, SUBCATEGORY)

async def save_other_subcategory(update: Update, context: CallbackContext) -> int:
    return await save_other_option(update, context, "subcategory", CONFIRM_SUBCATEGORY)

async def confirm_other_subcategory(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    await query.answer()
    
    if query.data == "confirm_subcategory":
        return await ask_size(update, context)
    elif query.data == "rewrite_subcategory":
        await query.edit_message_text("Напишите новую подкатегорию:")
        return OTHER_SUBCATEGORY

async def handle_other_color(update: Update, context: CallbackContext) -> int:
    return await handle_other_option(update, context, "color", OTHER_COLOR, COLOR)

async def save_other_color(update: Update, context: CallbackContext) -> int:
    return await save_other_option(update, context, "color", CONFIRM_COLOR)

async def confirm_other_color(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    await query.answer()
    
    if query.data == "confirm_color":
        return await ask_phone_number(update, context)
    elif query.data == "rewrite_color":
        await query.edit_message_text("Введите новый цвет:")
        return OTHER_COLOR

async def handle_other_source(update: Update, context: CallbackContext) -> int:
    return await handle_other_option(update, context, "source", OTHER_SOURCE, SOURCE)

async def save_other_source(update: Update, context: CallbackContext) -> int:
    return await save_other_option(update, context, "source", CONFIRM_SOURCE)

async def confirm_other_source(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    await query.answer()
    
    if query.data == "confirm_source":
        return await confirm_order(update, context)
    elif query.data == "rewrite_source":
        await query.edit_message_text("Введите новый источник:")
        return OTHER_SOURCE



async def confirm_order(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    await query.answer()

    category = context.user_data.get("category", "Не указано")
    subcategory = context.user_data.get("subcategory", "Не указано")
    length = context.user_data.get("length", "Не указано")
    width = context.user_data.get("width", "Не указано")
    glass = context.user_data.get("glass", "Не указано")
    color = context.user_data.get("color", "Не указано")
    source = context.user_data.get("source", "Не указано")
    phone_number = context.user_data.get("phone_number", "Не указано")

    order_summary = (f"📌 Ваш заказ:\n\n"
                     f"🔹 Категория: {category}\n"
                     f"🔹 Подкатегория: {subcategory}\n"
                     f"📏 Размеры:\n   - Высота: {length} м\n   - Ширина: {width} м\n"
                     f"🪟 Стекло: {glass}\n"
                     f"🎨 Цвет: {color}\n"
                     f"📞 Телефон: {phone_number}\n"
                     f"📍 Источник: {source}\n\n"
                     f"✅ Подтвердите или измените заказ:")

    keyboard = [
        [InlineKeyboardButton("✅ Отправить", callback_data="confirm_send")],
        [InlineKeyboardButton("✏️ Изменить", callback_data="confirm_edit")],
        [InlineKeyboardButton("🏠 В главное меню", callback_data="confirm_cancel")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await query.edit_message_text(order_summary, reply_markup=reply_markup, parse_mode="Markdown")
    return CONFIRM_ORDER

async def handle_confirm_order(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    await query.answer()

    if query.data == "confirm_send":
        return await complete_order(update, context) 

    elif query.data == "confirm_edit":
        return await start_order(update, context) 

    elif query.data == "confirm_cancel":
        await main_menu_from_query(query) 
        return ConversationHandler.END

async def complete_order(update: Update, context: CallbackContext) -> int:
    access_token = get_access_token()
    if not access_token:
        if update.callback_query:
            await update.callback_query.message.reply_text("❌ Произошла какая-то ошибка, напишите нам [в Telegram](https://t.me/+79953969908) об этом!!")
        else:
            await update.message.reply_text("❌ Произошла какая-то ошибка, напишите нам [в Telegram](https://t.me/+79953969908) об этом!!")
        return ConversationHandler.END

    tokens.default_token_manager(
        client_id=Config.CLIENT_ID,
        client_secret=Config.CLIENT_SECRET,
        subdomain=Config.SUBDOMAIN,
        redirect_url=Config.REDIRECT_URI,
        storage=tokens.FileTokensStorage()
    )

    class CustomLead(_Lead):
        category = custom_field.TextCustomField("Категория")
        subcategory = custom_field.TextCustomField("Подкатегория")
        length = custom_field.NumericCustomField("Высота")
        width = custom_field.NumericCustomField("Ширина")
        glass = custom_field.TextCustomField("Стекло")
        color = custom_field.TextCustomField("Цвет")
        phone_number = custom_field.TextCustomField("Номер телефона")
        source = custom_field.TextCustomField("Откуда узнали о нас")

    if update.callback_query:
        query = update.callback_query
        await query.answer()
        chat_id = query.message.chat_id
        message_sender = query.message.reply_text
    elif update.message:
        chat_id = update.message.chat_id
        message_sender = update.message.reply_text
    else:
        print("❌ Произошла какая-то ошибка, напишите нам [в Telegram](https://t.me/+79953969908) об этом!!")
        return ConversationHandler.END
    
    query = update.callback_query
    await query.answer()
    await query.edit_message_text("⏳ Подождите минуточку, создаем для вас новую сделку...")

    

    pipeline = Pipeline.objects.get(Config.PIPELINE_ID)

    status = next((s for s in pipeline.statuses if s.id == Config.STATUS_ID), None)

    try:
        length = float(context.user_data.get("length", 0) or 0)
        width = float(context.user_data.get("width", 0) or 0)

        glass = context.user_data.get("glass", "Не указано")
        if glass not in GLASS_OPTIONS and glass != "Не указано":
            glass = "Не указано"

        lead = CustomLead(
            name=f"Заказ от Telegram ({chat_id})",
            price=0,
            pipeline=pipeline,
            status=status,
            category=context.user_data.get("category", "Не указано"),
            subcategory=context.user_data.get("subcategory", "Не указано"),
            length=length,
            width=width,  
            glass=glass,
            color=context.user_data.get("color", "Не указано"),
            phone_number=context.user_data.get("phone_number", "Не указано"),
            source=context.user_data.get("source", "Не указано"),
        )

        lead.save()

        order_summary = (
            f"📌 *Новая сделка в AmoCRM*:\n\n"
            f"🔹 *Категория:* {context.user_data.get('category', 'Не указано')}\n"
            f"🔹 *Подкатегория:* {context.user_data.get('subcategory', 'Не указано')}\n"
            f"📏 *Размеры:*\n"
            f"   - *Высота:* {length} м\n"
            f"   - *Ширина:* {width} м\n"
            f"🪟 *Стекло:* {glass}\n"
            f"🎨 *Цвет:* {context.user_data.get('color', 'Не указано')}\n"
            f"📞 *Телефон:* {context.user_data.get('phone_number', 'Не указано')}\n"
            f"📍 *Источник:* {context.user_data.get('source', 'Не указано')}\n\n"
            f"✅ *ID сделки:* {lead.id}\n"
            f"--------------------------------------"
        )

        await context.bot.send_message(
            chat_id=Config.SUPPORT_CHAT_ID,
            text=order_summary,
            parse_mode="Markdown"
        )

        
        keyboard = [[InlineKeyboardButton("🏠 Вернуться в главное меню", callback_data="back_to_main")]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text(
            text=f"✅ Сделка успешно создана: {lead.id}!!\nСейчас работаю с другим клиентом, как освобожусь, дам информацию!",
            reply_markup=reply_markup
        )

    except Exception as e:
        print("❌ Произошла какая-то ошибка, напишите нам [в Telegram](https://t.me/+79953969908) об этом!!")
        await message_sender("❌ Произошла какая-то ошибка, напишите нам [в Telegram](https://t.me/+79953969908) об этом!!")

    return ConversationHandler.END

async def cancel_order_and_show_menu(update: Update, context: CallbackContext):
    context.user_data.clear()

    if update.effective_chat.id in context.application.conversations:
        context.application.conversations[update.effective_chat.id].cancel()

    await main_menu(update, context)
    return ConversationHandler.END

async def cancel_order_and_show_menu(update: Update, context: CallbackContext):
    context.user_data.clear()

    if context.chat_data.get("conversation"):
        context.chat_data["conversation"].update_state(None)

    return await main_menu(update, context)


async def handle_text(update: Update, context: CallbackContext):
    text = update.message.text.lower()

    if text == "меню":
        context.user_data.clear()
        await cancel_order_and_show_menu(update, context)
    else:
        await update.message.reply_text("Извините, я не понимаю этот запрос. Напишите \"меню\", чтобы продолжить работу.")
    
    return ConversationHandler.END

def main() -> None:
    application = ApplicationBuilder().token(Config.BOT_TOKEN).build()

    application.add_handler(CommandHandler('start', cancel_order_and_show_menu))
    application.add_handler(CommandHandler('menu', cancel_order_and_show_menu))

    application.add_handler(CallbackQueryHandler(about_company, pattern='^about$'))
    application.add_handler(CallbackQueryHandler(gallery, pattern='^gallery$'))
    application.add_handler(CallbackQueryHandler(feedback, pattern='^feedback$'))
    application.add_handler(CallbackQueryHandler(faq, pattern='^faq$'))
    application.add_handler(CallbackQueryHandler(back_to_main, pattern='^back_to_main$'))
    application.add_handler(CallbackQueryHandler(handle_photo_navigation, pattern='^(prev_photo|next_photo|back_to_main)$'))
    application.add_handler(CallbackQueryHandler(support, pattern='^support$'))

    order_handler = ConversationHandler(
        entry_points=[CallbackQueryHandler(start_order, pattern="^order$")],
        states={
            CATEGORY: [CallbackQueryHandler(choose_subcategory)],

            SUBCATEGORY: [
                CallbackQueryHandler(handle_subcategory_selection, pattern="^sub_.*$"),
                CallbackQueryHandler(ask_size, pattern="^(?!back_to_category|other_subcategory).*$"),
                CallbackQueryHandler(back_to_category, pattern="^back_to_category$"),
                CallbackQueryHandler(handle_other_subcategory, pattern="^other_subcategory$")
            ],
            OTHER_SUBCATEGORY: [MessageHandler(filters.TEXT & ~filters.COMMAND, save_other_subcategory)],
            CONFIRM_SUBCATEGORY: [
                CallbackQueryHandler(confirm_other_subcategory, pattern="^(rewrite_subcategory|confirm_subcategory)$")
            ],

            SIZE_KNOWN: [CallbackQueryHandler(handle_size_known, pattern="^(yes|no|back_to_category)$")],
            LENGTH: [
                CallbackQueryHandler(handle_length_input, pattern="^length_.*$"),
                CallbackQueryHandler(back_to_size_known, pattern="^back_to_size_known$")
            ],
            WIDTH: [
                CallbackQueryHandler(handle_width_input, pattern="^width_.*$"),
                CallbackQueryHandler(back_to_length, pattern="^back_to_length$")
            ],

            GLASS: [
                CallbackQueryHandler(ask_color, pattern="^(?!back_to_size_known).*$"),
                CallbackQueryHandler(back_to_size_known, pattern="^back_to_size_known$")
            ],

            COLOR: [
                CallbackQueryHandler(handle_color_selection, pattern="^(?!back_to_glass|upload|skip|other_color).*$"),
                CallbackQueryHandler(back_to_glass, pattern="^back_to_glass$"),
                CallbackQueryHandler(handle_other_color, pattern="^other_color$")
            ],
            OTHER_COLOR: [MessageHandler(filters.TEXT & ~filters.COMMAND, save_other_color)],
            CONFIRM_COLOR: [
                CallbackQueryHandler(confirm_other_color, pattern="^(rewrite_color|confirm_color)$")
            ],

            PHONE_NUMBER: [MessageHandler(filters.ALL, handle_phone_number)],
            
            SOURCE: [CallbackQueryHandler(handle_source_selection, pattern="^(?!back_to_phone_number|other_source).*$"),
                     CallbackQueryHandler(back_to_phone_number, pattern="^back_to_phone_number$"),
                     CallbackQueryHandler(handle_other_source, pattern="^other_source$")],
            OTHER_SOURCE: [MessageHandler(filters.TEXT & ~filters.COMMAND, save_other_source)],
            CONFIRM_SOURCE: [CallbackQueryHandler(confirm_other_source, pattern="^(rewrite_source|confirm_source)$")],
            CONFIRM_ORDER: [CallbackQueryHandler(handle_confirm_order, pattern="^(confirm_send|confirm_edit|confirm_cancel)$")]
        },
        fallbacks=[],
        per_user=True
    )

    application.add_handler(order_handler)
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))
    application.run_polling()
    

if __name__ == '__main__':
    main()

